use crate::error::{HostError, Result};
use crate::receipt::Receipt;
use execution_utils::setups;
use execution_utils::unrolled;
use execution_utils::unrolled::UnrolledProgramProof;
use execution_utils::unrolled_gpu::{UnrolledProver, UnrolledProverLevel};
use gpu_prover::execution::prover::ExecutionProverConfiguration;
use risc_v_simulator::abstractions::non_determinism::QuasiUARTSource;
use risc_v_simulator::cycle::IMStandardIsaConfigWithUnsignedMulDiv;
use riscv_transpiler::common_constants::rom::ROM_BYTE_SIZE;
use std::path::{Path, PathBuf};

const DEFAULT_RAM_BOUND_BYTES: usize = 1 << 30;
const DEFAULT_CPU_CYCLE_BOUND: usize = u32::MAX as usize;

/// Maximum proof layer generated by the prover.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Default)]
pub enum ProverLevel {
    Base,
    RecursionUnrolled,
    #[default]
    RecursionUnified,
}

impl ProverLevel {
    pub fn as_unrolled_level(self) -> UnrolledProverLevel {
        match self {
            ProverLevel::Base => UnrolledProverLevel::Base,
            ProverLevel::RecursionUnrolled => UnrolledProverLevel::RecursionUnrolled,
            ProverLevel::RecursionUnified => UnrolledProverLevel::RecursionUnified,
        }
    }
}

/// Prover backend used for proof generation.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Default)]
pub enum ProverBackend {
    Cpu,
    #[default]
    Gpu,
}

/// Proof generation parameters.
#[derive(Clone, Debug)]
pub struct ProveOptions {
    pub backend: ProverBackend,
    pub worker_threads: Option<usize>,
    pub cycles: Option<usize>,
    pub ram_bound: Option<usize>,
    pub level: ProverLevel,
}

impl Default for ProveOptions {
    fn default() -> Self {
        Self {
            backend: ProverBackend::Gpu,
            worker_threads: None,
            cycles: None,
            ram_bound: None,
            level: ProverLevel::RecursionUnified,
        }
    }
}

/// Proof and receipt produced by `prove`.
#[derive(Clone, Debug)]
pub struct ProveResult {
    pub proof: UnrolledProgramProof,
    pub cycles: u64,
    pub receipt: Receipt,
}

/// Backward-compatible helper that preserves the original host API contract.
pub fn prove(
    app_bin_path: &Path,
    input_words: &[u32],
    worker_threads: Option<usize>,
) -> Result<ProveResult> {
    let options = ProveOptions {
        worker_threads,
        ..ProveOptions::default()
    };
    prove_with_options(app_bin_path, input_words, &options)
}

pub fn prove_with_options(
    app_bin_path: &Path,
    input_words: &[u32],
    options: &ProveOptions,
) -> Result<ProveResult> {
    if !app_bin_path.exists() {
        return Err(HostError::Prover(format!(
            "binary not found: {}",
            app_bin_path.display()
        )));
    }
    if matches!(options.worker_threads, Some(0)) {
        return Err(HostError::Prover(
            "worker thread count must be greater than zero".to_string(),
        ));
    }

    match options.backend {
        ProverBackend::Gpu => prove_gpu(app_bin_path, input_words, options),
        ProverBackend::Cpu => prove_cpu(app_bin_path, input_words, options),
    }
}

fn prove_gpu(
    app_bin_path: &Path,
    input_words: &[u32],
    options: &ProveOptions,
) -> Result<ProveResult> {
    let prover = create_unrolled_prover(
        app_bin_path,
        options.worker_threads,
        options.level.as_unrolled_level(),
    )?;
    let oracle = QuasiUARTSource::new_with_reads(input_words.to_vec());
    let (proof, cycles) = prover.prove(0, oracle);
    let receipt = receipt_from_proof(&proof);

    Ok(ProveResult {
        proof,
        cycles,
        receipt,
    })
}

fn prove_cpu(
    app_bin_path: &Path,
    input_words: &[u32],
    options: &ProveOptions,
) -> Result<ProveResult> {
    if options.level != ProverLevel::Base {
        return Err(HostError::Prover(
            "CPU backend currently supports only level=base".to_string(),
        ));
    }

    let (app_bin_path, app_text_path) = resolve_bin_and_text_paths(app_bin_path)?;
    let (_, binary_u32) = setups::read_and_pad_binary(&app_bin_path);
    let (_, text_u32) = setups::read_and_pad_binary(&app_text_path);

    let cycles_bound = match options.cycles {
        Some(value) => value,
        None => {
            let outcome = crate::transpiler::run_transpiler(
                &app_bin_path,
                input_words,
                DEFAULT_CPU_CYCLE_BOUND,
                Some(&app_text_path),
            )?;
            outcome.cycles_executed
        }
    };
    if cycles_bound == 0 {
        return Err(HostError::Prover(
            "cycles bound must be greater than zero".to_string(),
        ));
    }

    let ram_bound = options.ram_bound.unwrap_or(DEFAULT_RAM_BOUND_BYTES);
    if ram_bound < ROM_BYTE_SIZE {
        return Err(HostError::Prover(format!(
            "ram bound must be at least {} bytes",
            ROM_BYTE_SIZE
        )));
    }

    let threads = resolve_worker_threads(options.worker_threads);
    let worker =
        execution_utils::prover_examples::prover::worker::Worker::new_with_num_threads(threads);
    let oracle = QuasiUARTSource::new_with_reads(input_words.to_vec());

    let proof = unrolled::prove_unrolled_for_machine_configuration_into_program_proof::<
        IMStandardIsaConfigWithUnsignedMulDiv,
    >(
        &binary_u32,
        &text_u32,
        cycles_bound,
        oracle,
        ram_bound,
        &worker,
    );
    let receipt = receipt_from_proof(&proof);

    Ok(ProveResult {
        proof,
        cycles: cycles_bound as u64,
        receipt,
    })
}

fn create_unrolled_prover(
    app_bin_path: &Path,
    worker_threads: Option<usize>,
    level: UnrolledProverLevel,
) -> Result<UnrolledProver> {
    let base_path = base_path(app_bin_path)?;
    let mut configuration = ExecutionProverConfiguration::default();
    if let Some(threads) = worker_threads {
        configuration.max_thread_pool_threads = Some(threads);
        configuration.replay_worker_threads_count = threads;
    }
    Ok(UnrolledProver::new(&base_path, configuration, level))
}

fn resolve_bin_and_text_paths(path: &Path) -> Result<(PathBuf, PathBuf)> {
    let base_path = base_path(path)?;
    let app_bin_path = PathBuf::from(format!("{base_path}.bin"));
    let app_text_path = PathBuf::from(format!("{base_path}.text"));

    if !app_bin_path.exists() {
        return Err(HostError::Prover(format!(
            "binary not found: {}",
            app_bin_path.display()
        )));
    }
    if !app_text_path.exists() {
        return Err(HostError::Prover(format!(
            "text file not found: {}",
            app_text_path.display()
        )));
    }

    Ok((app_bin_path, app_text_path))
}

fn base_path(app_bin_path: &Path) -> Result<String> {
    let path_str = app_bin_path
        .to_str()
        .ok_or_else(|| HostError::Prover("app path is not valid UTF-8".to_string()))?;
    if let Some(stripped) = path_str.strip_suffix(".bin") {
        Ok(stripped.to_string())
    } else {
        Ok(path_str.to_string())
    }
}

fn resolve_worker_threads(worker_threads: Option<usize>) -> usize {
    worker_threads
        .or_else(|| {
            std::thread::available_parallelism()
                .ok()
                .map(|count| count.get())
        })
        .unwrap_or(1)
}

fn receipt_from_proof(proof: &UnrolledProgramProof) -> Receipt {
    let mut registers = [0u32; 32];
    for (idx, reg) in proof
        .register_final_values
        .iter()
        .take(registers.len())
        .enumerate()
    {
        registers[idx] = reg.value;
    }
    Receipt::from_registers(registers)
}
